// Generated by CoffeeScript 1.3.3
(function() {
  'use strict';

  var Protocol, addDispatch, assertFn, defProtocol, dispatch, extend, supports,
    __hasProp = {}.hasOwnProperty,
    __slice = [].slice;

  assertFn = require('./native/function').assertFn;

  Protocol = (function() {

    function Protocol(spec) {
      var def, name;
      for (name in spec) {
        if (!__hasProp.call(spec, name)) continue;
        def = spec[name];
        this[name] = def;
        if (def.setName) {
          this[name].setName(name);
        }
      }
      this.supports = function() {
        return false;
      };
    }

    return Protocol;

  })();

  defProtocol = function(spec) {
    return new Protocol(spec);
  };

  dispatch = function(signature) {
    var fn, name;
    name = null;
    fn = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      fn.validate.apply(fn, args);
      return fn.impl.apply(fn, args);
    };
    fn.setName = function(fnName) {
      return name = fnName;
    };
    fn.impl = function(type) {
      throw new Error("Function not implemented " + name + " for " + type);
    };
    fn.validate = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (args.length !== signature.length) {
        throw new Error("Invalid invocation " + name);
      }
    };
    return fn;
  };

  addDispatch = function(proto, pred, name, fn) {
    var chain, supports;
    if (proto[name] == null) {
      throw new Error('Unknown function ' + name);
    }
    if (proto[name].impl == null) {
      throw new Error('Function not extendable ' + name);
    }
    assertFn(pred, 'Invalid predicate');
    assertFn(fn, 'Invalid function');
    chain = proto[name].impl;
    proto[name].impl = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (pred.apply(null, args)) {
        return fn.apply(null, args);
      } else {
        return chain.apply(null, args);
      }
    };
    supports = proto.supports;
    return proto.supports = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (pred.apply(null, args)) {
        return true;
      } else {
        return supports.apply(null, args);
      }
    };
  };

  extend = function(proto, pred, spec) {
    var fn, name, _results;
    _results = [];
    for (name in spec) {
      if (!__hasProp.call(spec, name)) continue;
      fn = spec[name];
      _results.push(addDispatch(proto, pred, name, fn));
    }
    return _results;
  };

  supports = function() {
    var args, proto;
    proto = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return proto.supports.apply(proto, args);
  };

  module.exports = {
    defProtocol: defProtocol,
    extend: extend,
    dispatch: dispatch,
    supports: supports
  };

}).call(this);
