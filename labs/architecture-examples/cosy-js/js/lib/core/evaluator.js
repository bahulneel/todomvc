// Generated by CoffeeScript 1.3.3
(function() {
  'use strict';

  var assertFn, assertStr, assoc, children, cosy, defProtocol, dispatch, doSeq, element, evaluate, extend, filter, frame, get, hashMap, isCosy, isStr, isTree, isTreeNode, list, lookup, lookupRef, map, parse, proto, root, stringify, supports, use, vec, _ref, _ref1, _ref2, _ref3, _ref4,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty;

  _ref = require('./protocol'), defProtocol = _ref.defProtocol, dispatch = _ref.dispatch, extend = _ref.extend, supports = _ref.supports;

  list = require('../protocol/list');

  _ref1 = require('../protocol/map'), assoc = _ref1.assoc, get = _ref1.get;

  hashMap = require('./hashMap').hashMap;

  _ref2 = require('./native/string'), isStr = _ref2.isStr, assertStr = _ref2.assertStr;

  _ref3 = require('./list'), doSeq = _ref3.doSeq, map = _ref3.map, vec = _ref3.vec, filter = _ref3.filter;

  assertFn = require('./native/function').assertFn;

  _ref4 = require('./reader'), isTreeNode = _ref4.isTreeNode, isTree = _ref4.isTree, isCosy = _ref4.isCosy, root = _ref4.node, children = _ref4.children, cosy = _ref4.cosy, element = _ref4.element;

  parse = function(str) {
    return (assertStr(str)).split(/\s/);
  };

  lookupRef = function(frame, parts) {
    var name, ref, rest;
    name = list.first(parts);
    rest = list.rest(parts);
    ref = get(frame, name);
    if (ref && rest) {
      return lookupRef(use(frame, ref), rest);
    } else {
      return ref;
    }
  };

  lookup = function(frame, str) {
    var location, ref;
    if (!isStr(str)) {
      return str;
    }
    str = str.replace(/^'(.*)'$/, '"$1"');
    ref = lookupRef(frame, str.split(/[.]/));
    if (ref == null) {
      if (/^(true|false|[\d"[{])/i.exec(str)) {
        ref = JSON.parse(str);
      } else {
        location = '';
        if (frame.__node != null) {
          location = ' at ' + frame.__node[0].toString();
        }
        throw new Error(("Symbol " + str + " not found") + location);
      }
    }
    return ref;
  };

  evaluate = function(cmd, frame) {
    var args, filterSymbol, fn, mapSymbol;
    if (isStr(cmd)) {
      cmd = parse(cmd);
    }
    fn = lookup(frame, list.first(cmd));
    assertFn(fn, 'Unknown function ' + list.first(cmd));
    mapSymbol = function(symbol) {
      if ((fn.raw != null) && fn.raw.exec(symbol)) {
        return symbol;
      } else {
        return lookup(frame, symbol);
      }
    };
    filterSymbol = function(symbol) {
      return (symbol != null) && symbol !== '';
    };
    args = vec(map(mapSymbol, filter(filterSymbol, list.rest(cmd))));
    if (get(frame, 'debug')) {
      console.log([list.first(cmd)].concat(args));
    }
    return fn.apply(null, [frame].concat(__slice.call(args)));
  };

  proto = defProtocol({
    apply: dispatch(function(type, frame) {})
  });

  extend(proto, (function(type) {
    return type === null;
  }), {
    apply: function(nil, frame) {
      return frame;
    }
  });

  extend(proto, isStr, {
    apply: function(str, frame) {
      return evaluate(str, frame);
    }
  });

  stringify = function(_obj, prefix) {
    var cmds, key, val;
    if (prefix == null) {
      prefix = '';
    }
    cmds = [];
    if (isStr(_obj)) {
      cmds.push(prefix + _obj);
    } else {
      for (key in _obj) {
        if (!__hasProp.call(_obj, key)) continue;
        val = _obj[key];
        cmds = cmds.concat(stringify(val, prefix + key + ' '));
      }
    }
    return cmds;
  };

  extend(proto, isCosy, {
    apply: function(_cosy, frame) {
      var cmd, cmds, newFrame, _i, _len;
      cmds = stringify(_cosy);
      for (_i = 0, _len = cmds.length; _i < _len; _i++) {
        cmd = cmds[_i];
        newFrame = proto.apply(cmd, frame);
        if (newFrame != null) {
          frame = newFrame;
        }
      }
      return frame;
    }
  });

  extend(proto, isTreeNode, {
    apply: function(node, frame) {
      var newFrame;
      newFrame = assoc(frame, "__node", element(node));
      return proto.apply(cosy(node), newFrame);
    }
  });

  extend(proto, (function(type) {
    return supports(list, type);
  }), {
    apply: function(list, frame) {
      doSeq((function(item) {
        return proto.apply(item, frame);
      }), list);
      return frame;
    }
  });

  extend(proto, isTree, {
    apply: function(tree, frame) {
      var continueFn, newFrame;
      continueFn = function() {};
      frame = assoc(frame, '__continue', (function() {
        return continueFn();
      }));
      newFrame = proto.apply(root(tree), frame);
      newFrame["__parent"] = newFrame;
      if ((newFrame != null ? newFrame.__delay : void 0) != null) {
        continueFn = function(nextFrame) {
          delete newFrame.__delay;
          delete frame.__continue;
          return proto.apply(children(tree), newFrame);
        };
      } else {
        proto.apply(children(tree), newFrame);
      }
      return frame;
    }
  });

  use = function(frame, obj) {
    return list.into(frame, hashMap(obj));
  };

  frame = function() {
    return hashMap({
      use: use
    });
  };

  module.exports = {
    apply: proto.apply,
    use: use,
    frame: frame,
    evaluate: evaluate
  };

}).call(this);
