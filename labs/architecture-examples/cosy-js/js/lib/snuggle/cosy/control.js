// Generated by CoffeeScript 1.3.3
(function() {
  'use strict';

  var Control, control, evaluate, extend, instance, isFn, isRef, map, mutable, parseArgs, registerChild, use, watchRef, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __slice = [].slice,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  map = require('../../protocol/map');

  mutable = require('../../protocol/mutable');

  _ref = require('../../core/reference'), isRef = _ref.isRef, watchRef = _ref.watchRef;

  _ref1 = require('../../core/evaluator'), evaluate = _ref1.evaluate, use = _ref1.use;

  isFn = require('../../core/native/function').isFn;

  parseArgs = function(args, instance) {
    var arg, newArgs, _i, _len;
    newArgs = [];
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      arg = args[_i];
      newArgs.push((isRef(arg)) && (arg.metadata.controls[instance].passRef !== true) ? mutable.get(arg) : arg);
    }
    return newArgs;
  };

  extend = function(tgtObj, srcObj, ctx) {
    var name, value, _results;
    _results = [];
    for (name in srcObj) {
      if (!__hasProp.call(srcObj, name)) continue;
      value = srcObj[name];
      _results.push((function(name, value) {
        if (isFn(value)) {
          return tgtObj[name] = function() {
            var args;
            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            return value.apply(ctx, args);
          };
        } else {
          tgtObj[name] = {};
          return extend(tgtObj[name], value, ctx);
        }
      })(name, value));
    }
    return _results;
  };

  registerChild = function(frame, child) {
    if (frame == null) {
      return;
    }
    if (frame.__control != null) {
      return frame.__control.children.push(child);
    } else if (frame !== frame.__parent) {
      return registerChild(frame.__parent, child);
    }
  };

  instance = 0;

  Control = (function() {

    function Control(frame, fn, args) {
      var apply, arg, index, ns, parts, _base, _base1, _base2, _base3, _i, _j, _len, _len1, _name, _name1, _ref2, _ref3, _ref4, _ref5,
        _this = this;
      this.frame = frame;
      this.destroy = __bind(this.destroy, this);

      this.empty = __bind(this.empty, this);

      if (!isFn(fn)) {
        if (this.frame.__parentNS != null) {
          return evaluate(['control', fn].concat(args), use(this.frame, this.frame.__parentNS));
        } else {
          throw new Error(fn + ' control not found');
        }
      }
      instance += 1;
      this.instance = instance;
      this.destructors = [];
      this.children = [];
      registerChild(this.frame, this);
      this.frame.__control = this;
      apply = function() {
        var newArgs;
        newArgs = parseArgs(args, _this.instance);
        return fn.apply(_this, newArgs);
      };
      ns = map.get(this.frame, 'namespace');
      extend(this, ns, this);
      this.cosy = {
        control: function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return evaluate(['control'].concat(args), frame);
        },
        cmd: function(element, cmd) {
          var newFrame;
          newFrame = map.assoc(frame, "__node", element);
          return evaluate(cmd, newFrame);
        }
      };
      this.props = map.get(this.frame, 'refs');
      this.element = map.get(this.frame, '__node');
      for (index = _i = 0, _len = args.length; _i < _len; index = ++_i) {
        arg = args[index];
        parts = /^([&])?(@|%)(.*)$/.exec(arg);
        if (isRef(args[index])) {
          if ((_ref2 = (_base = args[index].metadata).controls) == null) {
            _base.controls = {};
          }
          if ((_ref3 = (_base1 = args[index].metadata.controls)[_name = this.instance]) == null) {
            _base1[_name] = {};
          }
          args[index].metadata.controls[this.instance].passRef = true;
        }
        if ((parts != null) && parts[2] === '@' && (parts[3] != null)) {
          args[index] = this.props[parts[3]];
        }
        if ((parts != null) && parts[2] === '%' && (parts[3] != null)) {
          args[index] = this.global.getOrInitRef(parts[3]);
        }
        if (isRef(args[index])) {
          if ((_ref4 = (_base2 = args[index].metadata).controls) == null) {
            _base2.controls = {};
          }
          if ((_ref5 = (_base3 = args[index].metadata.controls)[_name1 = this.instance]) == null) {
            _base3[_name1] = {};
          }
          if ((parts != null) && parts[1] === '&') {
            args[index].metadata.controls[this.instance].passRef = true;
          }
          this.destructors.push((function(controls, index) {
            return function() {
              if (controls[index] != null) {
                return delete controls[index];
              }
            };
          })(args[index].metadata.controls, this.instance));
        }
      }
      for (_j = 0, _len1 = args.length; _j < _len1; _j++) {
        arg = args[_j];
        if (isRef(arg)) {
          this.watchRef(arg, apply);
        }
      }
      this.isInitialising = true;
      apply();
      this.isInitialising = false;
    }

    Control.prototype.empty = function() {
      var child;
      while (child = this.children.pop()) {
        child.destroy();
      }
      return this.element.html('');
    };

    Control.prototype.destroy = function() {
      var fn, _i, _len, _ref2;
      this.empty();
      _ref2 = this.destructors;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        fn = _ref2[_i];
        fn();
      }
      return this.element.remove();
    };

    return Control;

  })();

  control = function() {
    var args, fn, frame;
    frame = arguments[0], fn = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    new Control(frame, fn, args);
    return frame;
  };

  control.raw = /^&?[%@].+$/;

  module.exports = control;

}).call(this);
